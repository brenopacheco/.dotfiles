{

  "semaphore": {
    "prefix": ["semaphore", "open_semaphore", "create_semaphore", "new_semaphore"],
    "body": [
      "if (sem_open(${NAME}, 0644) != SEM_FAILED)",
      "  sem_unlink(${NAME});",
      "sem_t* sem = sem_open(${NAME}, O_CREAT | O_RDWR, 0644, value); // existing: sem_open(REQ, 0644)",
      "if (sem == SEM_FAILED) {",
      "  perror(\"Error(sem_open)\");",
      "  exit(1);",
      "}",
      "${0}",
      "sem_unlink(${NAME});"
    ]
  },
  "shared_memory": {
    "prefix": ["shared_memory", "open_sharedmemory", "create_sharedmemory", "new_sharedmemory"],
    "body": [
      "typedef int Buffer;",
      "int shm_size = sizeof(Buffer);",
      "*fd = shm_open(${NAME}, O_CREAT | O_TRUNC | O_RDWR, 0644); // existing: shm_open(SHM, O_RDWR, 0644)",
      "if (*fd < 1) {",
      "  perror(\"Error(shm_open)\");",
      "  exit(1);",
      "}",
      "if (ftruncate(*fd, shm_size) != 0) {",
      "  perror(\"Error(ftruncate)\");",
      "  exit(1);",
      "}",
      "Buffer* buf = mmap(NULL, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, *fd, 0);",
      "if (buf == MAP_FAILED) {",
      "  perror(\"Error(mmap)\");",
      "  exit(1);",
      "}",
      "${0}",
      "munmap(ticket, shm_size);",
      "close(fd);",
      "shm_unlink(${NAME});"
    ]
  },
  "sigaction": {
    "prefix": ["sigaction", "open_sigaction", "create_sigaction", "new_sigaction"],
    "body": [
      "// void _abort(int signo, siginfo_t* info, void* context){}",
      "$0",
      "struct sigaction act;",
      "act.sa_flags = SA_SIGINFO;",
      "act.sa_sigaction = _abort;",
      "sigemptyset(&act.sa_mask);",
      "sigaction(SIGINT, &act, NULL);"
    ]
  },
  "fork": {
    "prefix": ["open_fork", "create_fork", "new_fork", "fork"],
    "body": [
      "pid_t pid = fork();",
      "if (pid == -1) {",
      "  perror(\"Error(fork)\");",
      "  exit(1);",
      "}",
      "if (pid == 0) {",
      "  /* child's code */",
      "  ${0}",
      "}"
    ]
  },
  "wait": {
    "prefix": ["wait", "create_wait", "new_wait"],
    "body": [
      "  int status;",
      "  if (wait(&status) != -1) {",
      "    if (WIFEXITED(status)) printf(\"Exit status code: %d\\n\", WEXITSTATUS(status));"
    ]
  },
  "pipe": {
    "prefix": ["pipe", "create_pipe", "open_pipe", "new_pipe"],
    "body": [
      "int fd[2];",
      "if(pipe(fd) == -1) {",
      "  perror(\"Error(pipe)\");",
      "  exit(0);",
      "}"
    ]
  },

    "main": {
        "prefix": "main",
        "description": "main",
        "body": [
        "int main(int argc, char *argv[])",
        "{",
        "    ${0}",
        "    return 0;",
        "}"
        ]
    },
    "#inc<>": {
        "prefix": "inc",
        "description": "include <library.h>",
        "body": [
        "#include <$0"
        ]
    },
    "ndef": {
        "prefix": "ndef",
        "description": "ndef",
        "body": [
        "#ifndef $1",
        "#define ${1:SYMBOL} ${2:value}",
        "$0 just print file name",
        "#endif /* ifndef $1 */"
        ]
    },
    "def": {
        "prefix": "def",
        "description": "def",
        "body": [
        "#define ${1:SYMBOL} ${0:value}"
        ]
    },
    "ifdef": {
        "prefix": "ifdef",
        "description": "ifdef",
        "body": [
        "#ifdef ${1:FOO}",
        "    ${0:#define }",
        "#endif"
        ]
    },
    "#if": {
        "prefix": "#if",
        "description": "#if",
        "body": [
        "#if ${1:FOO}",
        "    ${0:${TM_SELECTED_TEXT}}",
        "#endif"
        ]
    },
    "once": {
        "prefix": "once",
        "description": "once",
        "body": [
        "#ifndef ${1:${VIM:toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))}}",
        "#define $1",
        "${0}",
        "#endif /* end of include guard: $1 */"
        ]
    },
    "nocxx": {
        "prefix": "nocxx",
        "description": "nocxx",
        "body": [
        "#ifdef __cplusplus",
        "extern \"C\" {",
        "#endif",
        "${0}",
        "#ifdef __cplusplus",
        "} /* extern \"C\" */",
        "#endif"
        ]
    },
    "if": {
        "prefix": "if",
        "description": "if",
        "body": [
        "if (${1:true}) {",
        "    ${0:${TM_SELECTED_TEXT}}",
        "}"
        ]
    },
    "ife": {
        "prefix": "ife",
        "description": "ife",
        "body": [
        "if (${1:true}) {",
        "    ${2:${TM_SELECTED_TEXT}}",
        "} else {",
        "    ${0}",
        "}"
        ]
    },
    "el": {
        "prefix": "el",
        "description": "el",
        "body": [
        "else {",
        "    ${0:${TM_SELECTED_TEXT}}",
        "}"
        ]
    },
    "elif": {
        "prefix": "elif",
        "description": "elif",
        "body": [
        "else if (${1:true}) {",
        "    ${0:${TM_SELECTED_TEXT}}",
        "}"
        ]
    },
    "ifi": {
        "prefix": "ifi",
        "description": "ifi",
        "body": [
        "if (${1:true}) ${0};"
        ]
    },
    "t": {
        "prefix": "t",
        "description": "t",
        "body": [
        "${1:/* condition */} ? ${2:a} : ${0:b}"
        ]
    },
    "switch": {
        "prefix": "switch",
        "description": "switch",
        "body": [
        "switch (${1:/* variable */}) {",
        "    case ${2:/* variable case */}:",
        "        ${0}",
        "        break;",
        "    default:",
        "        ${6:/* match none */}",
        "}"
        ]
    },
    "case": {
        "prefix": "case",
        "description": "case",
        "body": [
        "case ${1:/* variable case */}:",
        "    ${0}",
        "    break;"
        ]
    },
    "ret": {
        "prefix": "ret",
        "description": "ret",
        "body": [
        "return ${0};"
        ]
    },
    "for": {
        "prefix": "for",
        "description": "for",
        "body": [
        "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {",
        "    ${0}",
        "}"
        ]
    },
    "forr": {
        "prefix": "forr",
        "description": "forr",
        "body": [
        "for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {",
        "    ${0}",
        "}"
        ]
    },
    "while": {
        "prefix": "while",
        "description": "while",
        "body": [
        "while (${1:/* condition */}) {",
        "    ${0:${TM_SELECTED_TEXT}}",
        "}"
        ]
    },
    "do": {
        "prefix": "do",
        "description": "do",
        "body": [
        "do {",
        "    ${0:${TM_SELECTED_TEXT}}",
        "} while (${1:/* condition */});"
        ]
    },
    "fun": {
        "prefix": "fun",
        "description": "fun",
        "body": [
        "${1:void} ${2:function_name}(${3})",
        "{",
        "    ${0}",
        "}"
        ]
    },
    "doc": {
        "prefix": "doc",
        "description": "doc",
        "body": [
        "/*! \\brief ${1:Brief function description here}",
        " *",
        " *  ${0:Detailed description of the function}",
        " *",
        " * \\return ${3:Return parameter description}",
        " */"
        ]
    },
    "typedef": {
        "prefix": "typedef",
        "description": "typedef",
        "body": [
        "typedef ${1:int} ${0:MyCustomType};"
        ]
    },
    "struct": {
        "prefix": "struct",
        "description": "struct",
        "body": [
        "struct ${1:Name} {",
        "    ${0:/* data */}",
        "};"
        ]
    },
    "type": {
        "prefix": "type",
        "description": "typedef struct",
        "body": [
        "typedef struct ${1:S} {",
        "    ${0:int x;}",
        "} ${1:S};"
        ]
    },
    "tds": {
        "prefix": "tds",
        "description": "tds",
        "body": [
        "/*! \\struct $2",
        " *  \\brief ${5:Brief struct description}",
        " *",
        " *  ${6:Detailed description}",
        " */",
        "typedef struct ${2:_$1 }{",
        "    m_${3:Data} /*!< ${4:Description} */",
        "} ${1:${VIM:vim_snippets#Filename('$1_t', 'name')}};"
        ]
    },
    "enum": {
        "prefix": "enum",
        "description": "enum",
        "body": [
        "/*! \\enum $1",
        " *",
        " *  ${2:Detailed description}",
        " */",
        "enum ${1:name} { ${2} };"
        ]
    },
    "tde": {
        "prefix": "tde",
        "description": "tde",
        "body": [
        "/*! \\enum $2",
        " *",
        " *  ${4:Detailed description}",
        " */",
        "typedef enum {",
        "    ${1:Data} /*!< ${3:Description} */",
        "} ${2:foo};"
        ]
    },
  "comment": {
    "prefix": ["comment"],
    "body": [
      "/* ${TM_SELECTED_TEXT}${0} */"
    ]
  }
}
